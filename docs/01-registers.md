# Learning about Registers

One of the essential building blocks in Verilog and Clash is the Regsiters.
Let's work through some simple Clash register examles to become more familiar
with them.

We can create registers using the `register` funciton from the `Clash.Prelude`.

-------

__**FROM THE DOCUMENTATION**__

``` haskell
register :: forall dom a. (HiddenClockResetEnable dom, NFDataX a)	 
         => a -> Signal dom a -> Signal dom a
```

`register i s` delays the values in Signal `s` for one cycle, and sets the value
at time 0 to `i`

Parameters:

1. Reset value. register outputs the reset value when the reset is active. If
   the domain has initial values enabled, the reset value will also be the
   initial value.
2. Signal. 

Example from Documentation:

``` haskell
>>> sampleN @System 5 (register 8 (fromList [1,1,2,3,4]))
[8,8,1,2,3]
```

-------

Things to note:

- The `initial` value is output 2x times the first time the Register is used /
  clocked / whatever. 
- The `@System` sets the register domain (clock type, reset type, other stuff).
- The `fromList` function simply creates a Signal from a list 
- The `sampleN` function allows us to take a number of samples from the register

That's really something. Maybe an example could help me understand a bit better.

## Simple Up Counter

Let's write a simple up counter, which counts up to $2^n$. In verilog, this
could be something like:

```

module UpCounter(input wire CLK,
                 input wire RST,
                 input wire EN,
                 output reg [3:0] DATA);

parameter THRESHOLD = 10;

always @(posedge CLK)
    if (RST) DATA <= 0
    else if (EN)
        if (DATA < THRESHOLD)
            DATA <= DATA + 1;
        else 
            DATA <= 0;
```

We can do the same thing in clash. Let's start with a simple up counter without
a threhsold:

``` haskell
countUp :: HiddenClockResetEnable dom => Signal dom (Unsigned 4)
countUp = register 0 (countUp + 1)
```

Which we can test in `clashi` with `sampleN`:

``` bash
clashi> sampleN @System 20 countUp
[0,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,0,1,2]
```

Let's add a threshold:

``` haskell
countUp' :: HiddenClockResetEnable dom => Unsigned 4 -> Signal dom (Unsigned 4)
countUp' threshold = counter
    where counter = register 0 (goUp <$> counter)
          goUp v = if v == threshold then 0 else v + 1
```

And test this:

``` bash
clashi> sampleN @System 20 (countUp' 10)
[0,0,1,2,3,4,5,6,7,8,9,10,0,1,2,3,4,5,6,7]
```

Awesome! I wonder how the Verilog compares? We can generate Verilog from the
Clash if we provide a `TopEntity` definition in our CountUp module:

``` haskell
topEntity :: Clock System
          -> Reset System
          -> Enable System
          -> Signal System (Unsigned 4)
topEntity = exposeClockResetEnable $ countUp' 10

{-# OPAQUE topEntity #-}

{-# ANN topEntity
    (Synthesize
        { t_name = "countUp"
        , t_inputs = [ PortName "CLK"
                     , PortName "RST"
                     , PortName "EN"
                     ]
        , t_output = PortName "DATA"
        }
    ) #-}
```

We can not generate verilog:

``` bash
> stack run clash -- Play.Registers.CountUp --verilog
GHC: Setting up GHC took: 0.279s
GHC: Compiling and loading modules took: 0.460s
Clash: Parsing and compiling primitives took 0.727s
GHC+Clash: Loading modules cumulatively took 2.129s
Clash: Compiling Play.Registers.CountUp.topEntity
Clash: Normalization took 0.186s
Clash: Netlist generation took 0.002s
Clash: Compiling Play.Registers.CountUp.topEntity took 0.320s
Clash: Total compilation took 2.450s
```

This generates Verilog in the `Verilog/Play.Registers.CountUp/` folder, under
`countUp.v`

``` verilog
/* AUTOMATICALLY GENERATED VERILOG-2001 SOURCE CODE.
** GENERATED BY CLASH 1.8.1. DO NOT MODIFY.
*/
`default_nettype none
`timescale 100fs/100fs
module countUp
    ( // Inputs
      input wire  CLK // clock
    , input wire  RST // reset
    , input wire  EN // enable

      // Outputs
    , output wire [3:0] DATA
    );
  reg [3:0] counter = 4'd0;
  wire [3:0] c$counter_app_arg;

  // register begin
  always @(posedge CLK or  posedge  RST) begin : counter_register
    if ( RST) begin
      counter <= 4'd0;
    end else if (EN) begin
      counter <= c$counter_app_arg;
    end
  end
  // register end

  assign c$counter_app_arg = (counter == 4'd10) ? 4'd0 : (counter + 4'd1);

  assign DATA = counter;


endmodule
```

This looks mostly the same. So we're all done! Right? 

Most of the "Retroclash" book using `SNat` values to parameterize functions to
improve the generated Verilog. Let's try that and see how the generated Verilog
changes.

## Simple Up Counter 2

Let's go back to our simple up counter:

``` haskell
countUp :: HiddenClockResetEnable dom => Signal dom (Unsigned 4)
countUp = register 0 (countUp + 1)
```

We can modify the simple counter to be parametrizable using the Type System
using `KnownNat`:

``` haskell
countUp' :: forall n dom. (HiddenClockResetEnable dom, KnownNat n) => Signal dom (Unsigned n)
countUp' = register 0 (countUp' + 1)
```

Which makes calling the thing a bit more tricky, but we can specify the register
size using the type system:

``` haskell
clashi> sampleN 7 (countUp' :: Signal System (Unsigned 2))
[0,0,1,2,3,0,1]
```

Cool!  We can use `SNat` numbers to parameterize this a bit differently:

``` haskell
countUp'' :: forall n dom. (HiddenClockResetEnable dom, KnownNat n) => SNat n -> Signal dom (Unsigned n)
countUp'' _ = s
    where s = register 0 (s + 1)
```

Which works as follows:

``` haskell
clashi> sampleN @System 10 (countUp'' (SNat @2))
[0,0,1,2,3,0,1,2,3,0]
clashi> sampleN @System 10 (countUp'' (SNat @3))
[0,0,1,2,3,4,5,6,7,0]
```

If we want to count up to a particular threshold (which is often what we want)
we can modify how we use `SNat`:

``` haskell
countUp''' :: forall n dom. (HiddenClockResetEnable dom, KnownNat n) 
           => (1 <= n)
           => SNat n -> Signal dom (Unsigned (CLog 2 n))
countUp''' _ = counter
    where counter = register 0 (goUp <$> counter)
          threshold = snatToNum (SNat @n) - 1
          goUp v = if v < threshold then v + 1 else 0
```

There are a few things here that are important:

- Using `CLog 2 n` to set the number of bits our Unsigned result will be
- Using `1 <= n` to constrain the value of `n` so that the `CLog` is valid 
- Converting our `SNat` into a real value with `snatToNum`
- Using `n` in out function definition, which requires the language extension
  `ScopedTypeVariables`

Wow that's complicated! How does the verilog look?

``` bash
> stack run clash -- Play.Registers.CountUp2 --verilog
GHC: Setting up GHC took: 0.253s
GHC: Compiling and loading modules took: 0.383s
Clash: Parsing and compiling primitives took 0.686s
GHC+Clash: Loading modules cumulatively took 2.131s
Clash: Compiling Play.Registers.CountUp2.topEntity
Clash: Normalization took 0.084s
Clash: Netlist generation took 0.001s
Clash: Compiling Play.Registers.CountUp2.topEntity took 0.184s
Clash: Total compilation took 2.316s
```

``` verilog
/* AUTOMATICALLY GENERATED VERILOG-2001 SOURCE CODE.
** GENERATED BY CLASH 1.8.1. DO NOT MODIFY.
*/
`default_nettype none
`timescale 100fs/100fs
module countUp2
    ( // Inputs
      input wire  CLK // clock
    , input wire  RST // reset
    , input wire  EN // enable

      // Outputs
    , output wire [3:0] DATA
    );
  reg [3:0] counter = 4'd0;
  wire [3:0] c$counter_app_arg;

  // register begin
  always @(posedge CLK or  posedge  RST) begin : counter_register
    if ( RST) begin
      counter <= 4'd0;
    end else if (EN) begin
      counter <= c$counter_app_arg;
    end
  end
  // register end

  assign c$counter_app_arg = (counter < 4'd9) ? (counter + 4'd1) : 4'd0;

  assign DATA = counter;


endmodule
```

It looks the same! So what was the point?

With the `SNat` version, we can change the output Signal size as well as the
threshold with the same input. This is nice if we don't know what our threshold
needs to be, and can save us some space by designing the counter to be exactly
the right size for our application.

Basically: By being able to specify our output signal using `CLog 2` saves us a
little effort later. 

## Let's do it again: Down Counter

A down counter is pretty easy too:

``` haskell
countDown :: forall a dom. (HiddenClockResetEnable dom)
          => (Eq a, NFDataX a, Num a)
          => a -> Signal dom a
countDown start = counter
    where counter = register start (goDown <$> counter)
          goDown 0 = 0
          goDown i = i - 1
```

Tested:

``` haskell
clashi> sampleN @System 10 $ countDown 10
[10,10,9,8,7,6,5,4,3,2]
clashi> sampleN @System 10 $ countDown 5
[5,5,4,3,2,1,0,0,0,0]
```

Let's create a down counter with a SNat for fun:

``` haskell
countDown' :: forall n dom. (HiddenClockResetEnable dom)
           => KnownNat n
           => SNat n -> Signal dom (Unsigned n)
countDown' _ = counter
    where start = snatToNum (SNat @n)
          counter = counter start (goDown <$> counter)
          goDown 0 = 0
          goDown x = x - 1
```

Testing:

``` haskell
clashi> sampleN @System 10 $ countDown' (SNat @2)
[2,2,1,0,0,0,0,0,0,0]
clashi> sampleN @System 10 $ countDown' (SNat @3)
[3,3,2,1,0,0,0,0,0,0]
clashi> sampleN @System 10 $ countDown' (SNat @4)
[4,4,3,2,1,0,0,0,0,0]
clashi> sampleN @System 10 $ countDown' (SNat @5)
[5,5,4,3,2,1,0,0,0,0]
```

This is inefficient though: The output bit width increases linearly with n:

``` haskell
clashi> :t countDown' (SNat @3 )
countDown' (SNat @3 )
  :: (KnownDomain dom, ?clock::Clock dom, ?reset::Reset dom,
      ?enable::Enable dom) =>
     Signal dom (Unsigned 3)
clashi> :t countDown' (SNat @4 )
countDown' (SNat @4 )
  :: (KnownDomain dom, ?clock::Clock dom, ?reset::Reset dom,
      ?enable::Enable dom) =>
     Signal dom (Unsigned 4)
```

We can fix this by using the `CLog 2` Type level function maybe (From
GHC.TypeLits.Extra - CLog is Ceiling Log):

``` haskell
countDown'' :: forall n dom. (HiddenClockResetEnable dom)
            => (1 <= n)
            => KnownNat n
            => SNat n -> Signal dom (Unsigned (CLog 2 n))
countDown'' s = counter
    where start = snatToNum s 
          counter = register start (goDown <$> counter)
          goDown 0 = 0
          goDown x = x - 1
```

And the output type is now:

``` haskell
clashi> :t countDown'' (SNat @10)
countDown'' (SNat @10)
  :: (KnownDomain dom, ?clock::Clock dom, ?reset::Reset dom,
      ?enable::Enable dom) =>
     Signal dom (Unsigned (CLog 2 10))
```

Let's test `countDown''`:

``` haskell
clashi> sampleN @System 10 $ countDown'' (SNat @10)
[10,10,9,8,7,6,5,4,3,2]
clashi> sampleN @System 10 $ countDown'' (SNat @9)
[9,9,8,7,6,5,4,3,2,1]
clashi> sampleN @System 10 $ countDown'' (SNat @15)
[15,15,14,13,12,11,10,9,8,7]
clashi> sampleN @System 10 $ countDown'' (SNat @8)
[0,0,0,0,0,0,0,0,0,0]
clashi> sampleN @System 10 $ countDown'' (SNat @4)
[0,0,0,0,0,0,0,0,0,0]
clashi> sampleN @System 10 $ countDown'' (SNat @16)
[0,0,0,0,0,0,0,0,0,0]
```

WHOA what's happening!? Why 0's?

Let's calculate the Log:

$$ ceiling of \log_{2}{5} = 3 $$
$$ ceiling of \log_{2}{4} = 2 $$
$$ ceiling of \log_{2}{3} = 2 $$
$$ ceiling of \log_{2}{2} = 1 $$

How many bits to we need to represent the value 4? 0b100 -> 3 bits! But our
quick math calculates 2... so we have to add 1 bit OR use (n - 1) in the code.

This updates our code to be:

``` haskell
countDown'' :: forall n dom. (HiddenClockResetEnable dom)
            => (1 <= n)
            => KnownNat n
            => SNat n -> Signal dom (Unsigned (CLog 2 n))
countDown'' y = counter
    where start = snatToNum y
          counter = register (start - 1) (goDown <$> counter)
          goDown 0 = 0
          goDown x = x - 1
```

``` haskell
clashi> sampleN @System 10 $ countDown'' (SNat @10)
[9,9,8,7,6,5,4,3,2,1]
clashi> sampleN @System 10 $ countDown'' (SNat @8)
[7,7,6,5,4,3,2,1,0,0]
clashi> sampleN @System 10 $ countDown'' (SNat @4)
[4,4,3,2,1,0,0,0,0,0]
```

Cool beans. 

Walking through this second example helped me understand things a bit better. 

We could further improve out `DownCounter` using `ScopedTypeVariables`, but I
think we're OK here.

## Break 

Whew that was a lot of stuff. It's still not _super_ clear to me why `SNat`
values are the way to go, but I will trust the Author of `Retroclash` and
continue to use them.

`SNat` values are related at some level to Abstract Data Types / type level
programming. I found Rebecca Skinner's Blog post, "Introduction to Type Level
Programming" tremendously helpful.

    https://rebeccaskinner.net/posts/2021-08-25-introduction-to-type-level-programming.html

Her book, "Effective Haskell" does cover this as well. I find the blog post a
bit better than the book on this topic specifically, but the rest of the book
was awesome (well, what I could understand at the time).


## Debounce

Let's say we want to wait an amount of time if the provided input signal changes
before we update the output signal appropriately - how would we do this?

Firstly, to tell if a signal has changed we can use a register:

``` haskell
changed :: HiddenClockResetEnable dom 
        => (Eq a, NFDataX a) 
        => a -> Signal dom a -> Signal dom Bool
changed current input_signal = input_signal ./=. last_known_value
    where last_known_value = register current input_signal
```

Where `current` is the value of the input signal right now, and the
`input_sigal` is the signal that we want to check. We can see if an input signal
has changed by:

``` haskell
did_change = changed current input_signal
```

Once we know the input signal has changed, we need a timer. The timer should
"Reload" when things change, and count down to 0. (It could count up instead, I
like counting down though).

``` haskell
counter :: HiddenClockResetEnable dom
        => (1 <= n, KnownNat n)
        => SNat n -> Signal dom (Unsigned (1 + (CLog 2 n)))
counter y = register start (getNext (counter y))
    where start = (snatToNum y) - 1
          getNext c = mux did_change (pure start) (goDown <$> c)
          goDown 0 = 0
          goDown v = v - 1
```

This is a _slight_ change from `countDown''` - this count down timer has a
`reload`. 

The `mux` function is nice - it provides `if - else` functionality on `Signal
dom X` values. If our signal `did_change` then we reload our counter with the
`start` value. Otherwise we count down.

We can say that our input signal is `stable` when the time reaches 0:

``` haskell
stable = (pure 0) .==. (counter delay_time)
```

And once the `input_signal` is `stable` we can update the output. We can use the
register with an extra enable (`regEn`) to update the register when this
condition is met:

``` haskell
regEn current stable input_signal
```

Putting it all together:

``` haskell
changed :: HiddenClockResetEnable dom 
        => (Eq a, NFDataX a) 
        => a -> Signal dom a -> Signal dom Bool
changed current input_signal = input_signal ./=. last_known_value
    where last_known_value = register current input_signal

debounce :: forall n a dom. (HiddenClockResetEnable dom)
         => (1 <= n)
         => KnownNat n
         => (NFDataX a, Eq a)
         => SNat n -> a -> Signal dom a -> Signal dom a
debounce delay_time current input_signal = regEn current stable input_signal
    where did_change = changed current input_signal

          counter :: HiddenClockResetEnable dom
                  => (1 <= n, KnownNat n)
                  => SNat n -> Signal dom (Unsigned (CLog 2 n))
          counter y = register start (getNext (counter y))
              where start = (snatToNum y) - 1
                    getNext c = mux did_change (pure start) (goDown <$> c)
                    goDown 0 = 0
                    goDown v = v - 1
          
          stable = (pure 0) .==. (counter delay_time)
```

Let's test it out! We can use the `simulateN` function to provide an input
signal to a function:

``` haskell
clashi> simulateN @System 15 (debounce (SNat @6) 0) [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[0,0,0,0,0,0,0,0,0,1,1,1,1,1,1]
clashi> simulateN @System 15 (debounce (SNat @8) 0) [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[0,0,0,0,0,0,0,0,0,0,0,1,1,1,1]
```

Oddly, this doesn't work for 2 or 3?

``` haskell
clashi> simulateN @System 10 (debounce (SNat @2) 0) [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[0,0,0,1,1,1,1,1,1,1]
clashi> simulateN @System 10 (debounce (SNat @3) 0) [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[0,0,0,1,1,1,1,1,1,1]
```

Maybe 2 or 3 is lower than the propogation delay so it can't be done? or
something like that. Will need to check somehow? 

Before we can check with Verilator, we have to generate some Verilog.

## Generate Verilog 

We need to create a "top design" which instantiates the debouncer.

``` haskell
-- Required for our hacks, put with the other imports
import Clash.Annotations.TH

topEntity :: "CLK" ::: Clock System
          -> "IN"  ::: Signal System Bit
          -> "OUT" ::: Signal System Bit
topEntity clk = withClockResetEnable clk resetGen enableGen circuit
    where circuit inp = debounce (SNat @5) 0 inp 

makeTopEntity 'topEntity
```

Let's build and generate the Verilog:

``` bash
> stack run clash -- Play.Registers --verilog
```

This generates verilog to "./verilog/Play.Registers.topEntity/topEntity.v".

We can verilate this using verilator:

``` bash
> cd verilog
> verilator --cc Play.Registers.topEntity/topEntity.v
```

The `--cc` option generates C files to `obj_dir`. If we open up the
`VtopEntity.h` file we can check the input / output ports:


With this we can create a verilator Main file to test our code. Let's write:

``` cpp
...
VL_MODULE(VtopEntity) {
  public:
    // CELLS
    // Public to allow access to /*verilator_public*/ items;
    // otherwise the application code can consider these internals.
    VtopEntity_topEntity* topEntity;
    
    // PORTS
    // The application code writes and reads these signals to
    // propagate new values into/out from the Verilated model.
    VL_IN8(CLK,0,0);
    VL_IN8(IN,0,0);
    VL_OUT8(OUT,0,0);
```

The names we gave the signals align with what we called them, so that's awesome.

Let's write a main file to test things:

``` cpp
#include "VtopEntity.h
#include "verilated.h"

int main(void) {
    VtopEntity* top = new VtopEntity;

    // Initialize Trace HERE

    // Reset
    // Toggle Clock
    // Check Inputs / Outputs

    // C
    return 0;
}
```

To build with our test wrapper:

``` bash
> verilator -Wall --cc Play.Registers.topEntity/topEntity.v --exe --build main.c
```

## Other topics (TODO)

- Verilate the Debouncer and investivate what happens at 2 and 3

